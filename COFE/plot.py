"""Functions for plotting ordering results.

This module contains functions to plot results of the temporal reconstruction.
"""
import numpy as np
import matplotlib as mp
import seaborn as sns
import pandas as pd
import biothings_client


def plot_circular_ordering(results, time = None, period = 24, filename=None, 
                           X=None, **kwargs):
    """Plot the ellipse producted by the projection, the two CPCs and comparison 
    of the estimated and true phases

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    time : ndarray, optional
        the true/reference times of the samples, by default None
    """    
    sns.set_style("ticks")
    sns.set_context("notebook")
    fig = mp.pyplot.figure(**kwargs);
    gs = mp.gridspec.GridSpec(1, 3, width_ratios=[1.,1.,1.])
    ax = fig.add_subplot(gs[0, 0]);
    sns.scatterplot(x=results["CPCs"][:, 0], y=results["CPCs"][:, 1], ax=ax, 
                    legend=False, c=['0.3'] * results["CPCs"].shape[0])
    if X is not None:
        Y = X @ results['SLs'] / results['d']
        sns.scatterplot(x=Y[:, 0], y=Y[:, 1], ax=ax, hue=time, 
                        palette='twilight', legend=False)
    circle = mp.patches.Circle((0, 0), radius=1, alpha=0.5, 
                               ec='grey', ls=(0, (5, 3)), fill=False, lw=2.0)
    ax.add_patch(circle)
    ax.set_aspect('equal')
    ax.set_xlabel("cyclic principal component 1")
    ax.set_ylabel("cyclic principal component 2")
    sns.despine()

    ax = fig.add_subplot(gs[0, 1]);
    df = pd.DataFrame({'t': results['phase'], 
                      'CPC1': results['CPCs'][:, 0],
                      'CPC2': results['CPCs'][:, 1]})
    df = df.melt(id_vars='t', var_name='var', value_name='val')
    sns.scatterplot(x='t', y='val', hue='var', ax=ax, data=df, 
                    palette="colorblind")
    ax.set_xlabel("predicted sample time (/period)")
    ax.set_ylabel("cyclic principal components")
    ax.set_xlim([0,1])
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles=handles, labels=labels)
    sns.despine()

    ax = fig.add_subplot(gs[0, 2]);
    ax.plot([0,1],[0,1], lw=2.0, ls=(0, (5, 8)), c='r')
    if time is not None:
        sns.scatterplot(x = (time % period)/period, y = results['phase'], 
                        ax=ax, edgecolor='black', 
                        c=['0.3'] * results['phase'].shape[0])
        ax.set_aspect(1)
        sns.despine()
        ax.set_xlabel("true sample time (/period)")
        ax.set_ylabel("predicted sample time (/period)")
    fig.tight_layout()

    if isinstance(filename, str):
        mp.pyplot.savefig(filename)


def plot_cv_run(cv_results, **kwargs):
    """Plot the error performance and number of features used for different 
    choices of l1 threshold considered

    Parameters
    ----------
    cv_results : dict
        dictionary generated by the cross_validate function
    """    
    sns.set_style("ticks");
    sns.set_context("notebook")

    df1 = pd.DataFrame.from_dict({lamb: cv_results['runs'][i][:2] for i, 
                                  lamb in enumerate(cv_results['s_choices'])}, 
                                  orient='index', columns=['cv_mean', 'cv_se'])
    fig = mp.pyplot.figure(**kwargs)
    gs = mp.gridspec.GridSpec(1, 1)
    ax = fig.add_subplot(gs[0, 0]);
    ax.errorbar(df1.index, df1['cv_mean'], yerr=df1['cv_se'], fmt='ko-', 
                ecolor='dimgray')
    ax.set_xlabel("sparsity parameter")
    ax.set_ylabel("average imputation error")
    sns.despine()
    
    fig.tight_layout()

def plot_diagnostics(X, feature_dim = 'row', **kwargs):
    """Plot the comparison and distributions of the mean and standard deviation 
    of each feature

    Parameters
    ----------
    X : ndarray
        2D array with the raw data
    feature_dim : str, optional
        specification of whether the features are along rows ('row') or columns 
        ('col'), by default 'row'
    """    
    if feature_dim == 'row':
        axis = 1
    elif feature_dim == 'col':
        axis = 0

    sns.set_style("ticks");
    sns.set_context("notebook", font_scale=0.75)
    fig = mp.pyplot.figure(**kwargs);

    gs = mp.gridspec.GridSpec(1, 3)
    ax = fig.add_subplot(gs[0, 0]);
    ax.hexbin(x=X.mean(axis=axis), y=np.sqrt(X.var(axis=axis)), bins='log',
                cmap='viridis')
    ax.set_xlabel("Mean value of feature")
    ax.set_ylabel("Standard deviation of feature")

    ax = fig.add_subplot(gs[0, 1]);
    bin_edges = np.histogram_bin_edges(X.mean(axis=axis), bins=50)
    bin_edges = np.append(np.insert(bin_edges, 0, [-np.inf]), [np.inf])
    ax.hist(X.mean(axis=axis), bins=bin_edges, cumulative=-1, histtype='step', 
            lw=2.0)
    ax.grid(True)
    ax.set_xlabel("Mean value of feature")

    ax = fig.add_subplot(gs[0, 2]);
    bin_edges = np.histogram_bin_edges(1/X.std(axis=axis), bins=50)
    bin_edges = np.append(np.insert(bin_edges, 0, [-np.inf]), [np.inf])
    ax.hist(1/X.std(axis=axis), bins=bin_edges, cumulative=True, 
            histtype='step', lw=2.0)
    ax.grid(True)
    ax.set_xlabel("1/Standard deviation of feature")
    fig.tight_layout()

def plot_markers(results, translate=False, index_name="index", **kwargs):
    """Plot the features and the weights assigned to them in each of the two 
    sparse loading vectors

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    translate : bool, optional
        whether the feature names must be converted into gene symbols using 
        standard annotation databases, by default False
    index_name: str
        variable to use as index for the dataframe used to plot, by default 
        "index"
    """    
    sns.set_style("ticks");
    sns.set_context("notebook")

    df = pd.DataFrame(results["SLs"], index=results["features"], 
                      columns=["X","Y"])
    df = df.loc[(df!=0).any(axis=1)].sort_index()

    if translate:
        mg = biothings_client.get_client('gene')
        symbols = mg.getgenes(df.index.values, as_dataframe=True, 
                              fields='symbol')
        df.set_index(symbols["symbol"].values, inplace=True)

    df.reset_index(level=0, inplace=True)
    if index_name not in df.columns:
        ValueError("Name of the index column in incorrect")    
    
    df = pd.melt(df, id_vars=index_name, value_vars=['X','Y'], var_name="CPC")
    ax = sns.catplot(x="value", y="index", data=df, col="CPC", 
                     kind="bar", aspect=0.5, **kwargs)
    ax.set_xlabels("Loadings")
    ax.set_ylabels("Features")

def print_markers(results, translate=False, index_name="index"):
    """Print the features in each of the two sparse loading vectors

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    translate : bool, optional
        whether the feature names must be converted into gene symbols using 
        standard annotation databases, by default False
    index_name: str
        variable to use as index for the dataframe used to plot, by default 
        "index"
    """   
    sns.set_style("ticks");
    sns.set_context("notebook")

    df = pd.DataFrame(results["SLs"], index=results["features"], 
                      columns=["X","Y"])
    df = df.loc[(df!=0).any(axis=1)].sort_index()

    if translate:
        mg = biothings_client.get_client('gene')
        symbols = mg.getgenes(df.index.values, as_dataframe=True, 
                              fields='symbol')
        df.set_index(symbols["symbol"].values, inplace=True)

    df.reset_index(level=0, inplace=True)
    if index_name not in df.columns:
        ValueError("Name of the index column in incorrect") 
    df = pd.melt(df, id_vars=index_name, value_vars=['X','Y'], var_name="CPC")

    return(df["index"].unique())