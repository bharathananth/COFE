"""Functions for plotting ordering results.

This module contains functions to ....
"""

import numpy as np
import matplotlib.pyplot as mp
import seaborn as sns
import pandas as pd
import matplotlib.gridspec as gridspec
from biothings_client import get_client


def plot_circular_ordering(results, time = None, **kwargs):
    """Plot the ellipse producted by the projection, the two CPCs and comparison of the estimated and true phases

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    time : ndarray, optional
        the true/reference times of the samples, by default None
    """    
    sns.set_style("ticks")
    sns.set_context("notebook")
    fig = mp.figure(**kwargs);
    gs = gridspec.GridSpec(1, 3)
    ax = fig.add_subplot(gs[0, 0]);
    sns.scatterplot(x=results["CPCs"][:, 0], y=results["CPCs"][:, 1], ax=ax, palette='Set2', edgecolor='black')
    ax.set_aspect(1)
    ax.set_xlabel("circularized principal component 1")
    ax.set_ylabel("circularized principal component 2")
    sns.despine()

    ax = fig.add_subplot(gs[0, 1]);
    df = pd.DataFrame({'t': results['phase'], 
                      'CPC1': results['CPCs'][:, 0],
                      'CPC2': results['CPCs'][:, 1]})
    df = df.melt(id_vars='t', var_name='var', value_name='val')
    sns.scatterplot(x='t', y='val', hue='var', ax=ax, data=df, edgecolor='black')
    ax.set_xlabel("predicted sample phase (in fractions of the period)")
    ax.set_ylabel("circular principal components")
    ax.set_xlim([0,1])
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles=handles, labels=labels)
    sns.despine()

    ax = fig.add_subplot(gs[0, 2]);
    if time is not None:
        sns.scatterplot(x = (time % 24)/24, y = results['phase'], ax=ax, edgecolor='black')
        ax.set_aspect(1)
        sns.despine()
        ax.set_xlabel("true sample phase (in fractions of the period)")
        ax.set_ylabel("predicted sample phase (in fractions of the period)")
    fig.tight_layout()


def plot_cv_run(results, **kwargs):
    """Plot the error performance and number of features used for different choices of l1 threshold considered

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    """    
    sns.set_style("ticks");
    df1 = pd.DataFrame.from_dict({t: np.array(results['runs'][i]['test_se']).squeeze() for i, t in enumerate(results['t_choices'])})
    df1 = pd.melt(df1, var_name='t', value_name='se')

    fig = mp.figure(**kwargs)
    gs = gridspec.GridSpec(1, 2)
    ax = fig.add_subplot(gs[0, 0]);
    sns.boxplot(x="t", y="se", data=df1, ax=ax)
    ax.set_ylim([0, 0.5])
    ax.set_xlabel("Different choices of l1 constraint")
    ax.set_ylabel("Error of the fit")
    #ax.set_yscale("log")

    df2 = pd.DataFrame({'t': results['t_choices'], 'nfeature': [np.unique(np.nonzero(r['V'])[0]).shape[0] for r in results['runs']]})
    ax = fig.add_subplot(gs[0, 1]);
    sns.barplot(x="t", y="nfeature", data=df2, ax=ax)
    ax.set_xlabel("Different choices of l1 constraint")
    ax.set_ylabel("No. of unique features")    
    sns.despine()
    fig.tight_layout()

def plot_diagnostics(X, feature_dim = 'row', **kwargs):
    """Plot the comparison and distributions of the mean and standard deviation of each feature

    Parameters
    ----------
    X : ndarray
        2D array with the raw data
    feature_dim : str, optional
        specification of whether the features are along rows ('row') or columns ('col'), by default 'row'
    """    
    if feature_dim == 'row':
        axis = 1
    elif feature_dim == 'col':
        axis = 0

    sns.set_style("ticks");
    sns.set_context("notebook")
    fig = mp.figure(**kwargs);

    gs = gridspec.GridSpec(1, 3)
    ax = fig.add_subplot(gs[0, 0]);
    ax.scatter(X.mean(axis=axis), X.std(axis=axis), s=0.5)
    ax.set_xlabel("Mean value of the feature")
    ax.set_ylabel("Standard deviation of feature")

    ax = fig.add_subplot(gs[0, 1]);
    ax.hist(X.mean(axis=axis), bins=50)
    ax.set_xlabel("Mean value of the feature")

    ax = fig.add_subplot(gs[0, 2]);
    ax.hist(1/X.std(axis=axis), bins=50)
    ax.set_xlabel("Reciprocal standard deviation of the feature")
    fig.tight_layout()

def plot_markers(results, translate=False, **kwargs):
    """Plot the features and the weights assigned to them in each of the two sparse loading vectors

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    translate : bool, optional
        whether the feature names must be converted into gene symbols using standard annotation databases, by default False
    """    
    sns.set_style("ticks");
    sns.set_context("notebook")

    df = pd.DataFrame(results["SLs"], index=results["features"], columns=["X","Y"])
    df = df.loc[(df!=0).any(axis=1)].sort_index()

    if translate:
        mg = get_client('gene')
        symbols = mg.getgenes(df.index.values, as_dataframe=True, fields='symbol')
        df.set_index(symbols["symbol"].values, inplace=True)

    df.reset_index(level=0, inplace=True)
    df = pd.melt(df, id_vars="index", value_vars=['X','Y'], var_name="CPC")
    ax = sns.catplot(x="value", y="index", data=df, col="CPC", kind="bar", aspect=0.5, **kwargs)
    ax.set_xlabels("Loadings")
    ax.set_ylabels("Features")

def print_markers(results, translate=False):
    """Print the features in each of the two sparse loading vectors

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    translate : bool, optional
        whether the feature names must be converted into gene symbols using standard annotation databases, by default False
    """   
    sns.set_style("ticks");
    sns.set_context("notebook")

    df = pd.DataFrame(results["SLs"], index=results["features"], columns=["X","Y"])
    df = df.loc[(df!=0).any(axis=1)].sort_index()

    if translate:
        mg = get_client('gene')
        symbols = mg.getgenes(df.index.values, as_dataframe=True, fields='symbol')
        df.set_index(symbols["symbol"].values, inplace=True)

    df.reset_index(level=0, inplace=True)
    df = pd.melt(df, id_vars="index", value_vars=['X','Y'], var_name="CPC")

    return(df["index"].unique())