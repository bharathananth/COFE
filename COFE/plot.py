"""Functions for plotting ordering results.

This module contains functions to ....
"""
import numpy as np
import matplotlib as mp
import seaborn as sns
import pandas as pd
import biothings_client


def plot_circular_ordering(results, time = None, period = 24, filename=None, **kwargs):
    """Plot the ellipse producted by the projection, the two CPCs and comparison of the estimated and true phases

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    time : ndarray, optional
        the true/reference times of the samples, by default None
    """    
    sns.set_style("ticks")
    sns.set_context("notebook")
    fig = mp.pyplot.figure(**kwargs);
    gs = mp.gridspec.GridSpec(1, 3, width_ratios=[1.,1.,1.])
    ax = fig.add_subplot(gs[0, 0]);
    sns.scatterplot(x=results["CPCs"][:, 0], y=results["CPCs"][:, 1], ax=ax, palette='Set2', c=['0.3'] * results["CPCs"].shape[0])
    circle = mp.patches.Circle((0, 0), radius=results['d'], alpha=0.5, ec='grey', ls=(0, (5, 3)), fill=False, lw=2.0)
    ax.add_patch(circle)
    ax.set_aspect('equal')
    ax.set_xlabel("circularized principal component 1")
    ax.set_ylabel("circularized principal component 2")
    sns.despine()

    ax = fig.add_subplot(gs[0, 1]);
    df = pd.DataFrame({'t': results['phase'], 
                      'CPC1': results['CPCs'][:, 0],
                      'CPC2': results['CPCs'][:, 1]})
    df = df.melt(id_vars='t', var_name='var', value_name='val')
    sns.scatterplot(x='t', y='val', hue='var', ax=ax, data=df, palette="colorblind")
    ax.set_xlabel(r"predicted sample phase ($\times$ period)")
    ax.set_ylabel("circular principal components")
    ax.set_xlim([0,1])
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles=handles, labels=labels)
    sns.despine()

    ax = fig.add_subplot(gs[0, 2]);
    ax.plot([0,1],[0,1], lw=2.0, ls=(0, (5, 8)), c='r')
    if time is not None:
        sns.scatterplot(x = (time % period)/period, y = results['phase'], ax=ax, edgecolor='black', c=['0.3'] * results['phase'].shape[0])
        ax.set_aspect(1)
        sns.despine()
        ax.set_xlabel(r"true sample phase ($\times$ period)")
        ax.set_ylabel(r"predicted sample phase ($\times$ period)")
    fig.tight_layout()

    if isinstance(filename, str):
        mp.pyplot.savefig(filename)


def plot_cv_run(results, **kwargs):
    """Plot the error performance and number of features used for different choices of l1 threshold considered

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    """    
    sns.set_style("ticks");
    sns.set_context("notebook")

    df1 = pd.DataFrame.from_dict({lamb: results['runs'][i] for i, 
                                  lamb in enumerate(results['lambda_choices'])}, 
                                  orient='index', columns=['cv_mean', 'cv_se'])
    fig = mp.pyplot.figure(**kwargs)
    gs = mp.gridspec.GridSpec(1, 1)
    ax = fig.add_subplot(gs[0, 0]);
    ax.errorbar(df1.index, df1['cv_mean'], yerr=df1['cv_se'], fmt='ko-', ecolor='dimgray')
    ax.set_xlabel("different l1 constraints")
    ax.set_ylabel("residual sum of squared errors")
    sns.despine()
    
    fig.tight_layout()

def plot_diagnostics(X, feature_dim = 'row', **kwargs):
    """Plot the comparison and distributions of the mean and standard deviation of each feature

    Parameters
    ----------
    X : ndarray
        2D array with the raw data
    feature_dim : str, optional
        specification of whether the features are along rows ('row') or columns ('col'), by default 'row'
    """    
    if feature_dim == 'row':
        axis = 1
    elif feature_dim == 'col':
        axis = 0

    sns.set_style("ticks");
    sns.set_context("notebook")
    fig = mp.pyplot.figure(**kwargs);

    gs = mp.gridspec.GridSpec(1, 3)
    ax = fig.add_subplot(gs[0, 0]);
    sns.regplot(x=X.mean(axis=axis), y=np.sqrt(X.var(axis=axis)), lowess=True, ax=ax, scatter_kws={'s':0.5})
    ax.set_xlabel("Mean value of the feature")
    ax.set_ylabel("Standard deviation of feature")

    ax = fig.add_subplot(gs[0, 1]);
    bin_edges = np.histogram_bin_edges(X.mean(axis=axis), bins=50)
    bin_edges = np.append(np.insert(bin_edges, 0, [-np.inf]), [np.inf])
    ax.hist(X.mean(axis=axis), bins=bin_edges, cumulative=-1, histtype='step', lw=2.0)
    ax.grid(True)
    ax.set_xlabel("Mean value of the feature")

    ax = fig.add_subplot(gs[0, 2]);
    bin_edges = np.histogram_bin_edges(1/X.std(axis=axis), bins=50)
    bin_edges = np.append(np.insert(bin_edges, 0, [-np.inf]), [np.inf])
    ax.hist(1/X.std(axis=axis), bins=bin_edges, cumulative=True, histtype='step', lw=2.0)
    ax.grid(True)
    ax.set_xlabel("Reciprocal standard deviation of the feature")
    fig.tight_layout()

def plot_markers(results, translate=False, **kwargs):
    """Plot the features and the weights assigned to them in each of the two sparse loading vectors

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    translate : bool, optional
        whether the feature names must be converted into gene symbols using standard annotation databases, by default False
    """    
    sns.set_style("ticks");
    sns.set_context("notebook")

    df = pd.DataFrame(results["SLs"], index=results["features"], columns=["X","Y"])
    df = df.loc[(df!=0).any(axis=1)].sort_index()

    if translate:
        mg = biothings_client.get_client('gene')
        symbols = mg.getgenes(df.index.values, as_dataframe=True, fields='symbol')
        df.set_index(symbols["symbol"].values, inplace=True)

    df.reset_index(level=0, inplace=True)
    df = pd.melt(df, id_vars="index", value_vars=['X','Y'], var_name="CPC")
    ax = sns.catplot(x="value", y="index", data=df, col="CPC", kind="bar", aspect=0.5, **kwargs)
    ax.set_xlabels("Loadings")
    ax.set_ylabels("Features")

def print_markers(results, translate=False):
    """Print the features in each of the two sparse loading vectors

    Parameters
    ----------
    results : dict
        dictionary generated by the cross_validate function
    translate : bool, optional
        whether the feature names must be converted into gene symbols using standard annotation databases, by default False
    """   
    sns.set_style("ticks");
    sns.set_context("notebook")

    df = pd.DataFrame(results["SLs"], index=results["features"], columns=["X","Y"])
    df = df.loc[(df!=0).any(axis=1)].sort_index()

    if translate:
        mg = biothings_client.get_client('gene')
        symbols = mg.getgenes(df.index.values, as_dataframe=True, fields='symbol')
        df.set_index(symbols["symbol"].values, inplace=True)

    df.reset_index(level=0, inplace=True)
    df = pd.melt(df, id_vars="index", value_vars=['X','Y'], var_name="CPC")

    return(df["index"].unique())